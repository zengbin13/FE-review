# let 和 const 命令

|                        | var                  | let              | const          |
| ---------------------- | -------------------- | ---------------- | -------------- |
| 作用域                 | 函数级作用域         | 块级作用域       | 块级作用域     |
| 变量提升               | 变量提升 / undefiend | ReferenceError   | ReferenceError |
| 存放位置（执行上下文） | 变量环境             | 词法环境         | 词法环境       |
| 重复声明               | 可以                 | 同作用域下不可以 | 同上           |
| 可变性                 | 可变                 | 同上             | 只读常量       |

- for循环使用 `let` 保证计数器仅在循环体内有效，`var`将计数器 `i`泄露为全局变量

- `let / const`声明的变量不存在变量提升，只能在变量声明后使用，否则报错 `referenceError`

- **暂时性死区**——只要 `let / const`声明变量，声明的变量绑定在该块级区域，不受外部影响

  > 如果区块中存在let和const命令，该区块对 let / const 命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错

  ```js
  var tmp = 123;
  if (true) {
     tmp = 'abc' // ReferenceError
     let tmp;
  }
  ```

- `const`一旦声明变量，需立即初始化，指向内存地址保存值不可变
  - 复杂数据类型，内存地址不可变，数据可变

- let / const 声明的变量为非全局变量，`window.a //undefined`



### 块级作用域

```js
//IIFE 立即执行函数
（function () {
    var tmp = ...;
    ...
}())

// 块级作用域
{
    let tmp = ...;
    ...
}
```

- ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用



# 变量的解构赋值

ES6 允许按照一定模式，**从数组和对象中提取值，对变量进行赋值**

### 数组——解构赋值 

- **解构模式**：数组中提取值，按照对应位置，对变量赋值

  ```js
  let [a, b, c] = [1, 2, 3]
  let [head, ...tail] = [1, 2, 3, 4];
  ```

- 解构不成功，变量的值就等于`undefined`

- 解构赋值指定默认值，默认值生效条件，变量值为 `undefined`

  ```js
  let [foo = true] = [];
  let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
  ```

### 对象——解构赋值

- **解构模式**：对象的属性没有次序，变量必须与属性同名，才能取到正确的值

  ```js
  let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
  ```

- 解构失败，变量的值等于`undefined`

  ```js
  let { baz } = { foo: 'aaa', bar: 'bbb' };
  baz // undefined
  ```

- 内部机制——前面变量名匹配，后面变量名赋值

  ```js
  let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
  ```

  