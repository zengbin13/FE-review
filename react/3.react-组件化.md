# react 组件化开发



## 组件的定义方式

### 函数组件

```jsx
function App() {
  return (
    <div className="App">
      函数式组件
    </div>
  );
}
```

- 不具备this(组件实例)
- 没有内部状态（state）
- 不具有生命周期



### 类组件

```jsx
import { Component } from "react";

class App extends Component {
  constructor(props) {
    super(props)
    this.state = {
      message: '类组件的内部状态'
    }
  }
  render() {
    return (
      <h2>{this.state.message}</h2>
    )
  }
}
```

- 类组件需继承自 `React.Component`
- 类组件必须实现 `render`方法
- 使用 `this.state` 维护组件内部的数据
- 当render被调用时，将检查 `this.state`和 `this.props`的变化并返回



### render函数的返回值

| 返回值类型          | 描述                                          |
| ------------------- | --------------------------------------------- |
| **React元素**       | 通过JSX创建，DOM节点或自定义组件都为react元素 |
| **数组或fragments** | 使得render函数可以返回多个元素                |
| **portals**         | 可以渲染子节点到不同DOM子树中                 |
| 字符串或数值        | 在DOM中渲染为文本节点                         |
| 布尔值或null        | 不进行渲染                                    |



## 类组件的生命周期

![image-20210104161503203](3.react-组件化.assets/image-20210104161503203.png)

![image-20210104163837545](3.react-组件化.assets/image-20210104163837545.png)

### 挂载阶段

——当组件实例被创建并插入 DOM 中时

#### **constructor()**

```js
constructor(props)
```

- 作用
  - 通过给 `this.state`赋值对象来初始化**内部state**
  - 为**事件处理函数**绑定实例 (this)
- 不初始化state 或者 不进行方法绑定，可不实现构造函数
- **不能调用 `setState()` 方法**



#### getDerivedStateFromProps()

```js
static getDerivedStateFromProps(props, state)
```

- 在调用 render 方法前调用，并且在初始挂载及后续更新时都被调用
- **返回一个对象来更新 state**，如果返回 null 则不更新任何内容
- 此方法无权访问组件实例



#### **render()**

```js
render()
```

- `render()` 方法是 class 组件中唯一必须实现的方法
- 当 `render` 被调用时，将检查 `this.props` 和 `this.state` 的变化并返回以下类型
  - **React 元素**
  - **数组或 fragments**
  - **Portals**
  - **字符串或数值类型**
  - **布尔类型或 `null`**

- `render()` 函数应为纯函数——在不修改组件 state 的情况下，每次调用时都返回相同的结果



#### **componentDidMount()**

```js
componentDidMount()
```

- 在组件挂载后（插入 DOM 树中）立即调用
- **使用场景**
  - 发送网络请求，获取数据
  - 添加订阅
  - 依赖于DOM的操作



### 更新阶段

——当组件的 props 或 state 发生变化时会触发更新

#### getDerivedStateFromProps()



#### shouldComponentUpdate() 

```js
shouldComponentUpdate(nextProps, nextState)
```

- 根据 `shouldComponentUpdate()` 的返回值，是否重新执行render方法
- 默认行为： state 每次发生变化组件都会重新渲染
- 首次渲染或使用 `forceUpdate()` 时不会调用该方法



#### **render()**



#### getSnapshotBeforeUpdate()

```js
getSnapshotBeforeUpdate(prevProps, prevState)
```

- 在最近一次渲染输出（提交到 DOM 节点）之前调用
- 让组件能**在发生更改之前从 DOM 中捕获一些信息**
- 返回值将作为参数传递给 `componentDidUpdate()`



#### **componentDidUpdate()**

```js
componentDidUpdate(prevProps, prevState, snapshot)
```

- 在更新后会被立即调用
- 首次渲染不会执行此方法



### 卸载阶段

#### **componentWillUnmount()**

```
componentWillUnmount()
```

- 在组件卸载及销毁之前直接调用
- `componentWillUnmount()` 中**不应调用 `setState()`**
- 使用场景
  - 清除 timer
  - 取消网络请求
  - 清除在 `componentDidMount()` 中创建的订阅





## 组件间的通信方式

### 父传子

- 父组件通过 **属性 = 值** 的形式给子组件传递数据
- 子组件通过 **props** 参数获取父组件传递的数据

```jsx
//父组件 app.js

import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        {/*父组件传递数据*/}
        <ChildCom name="小鱼" age={18} level="20"></ChildCom>
        <ChildComF name="小曾" age={20} level="24"></ChildComF>
      </div>
    )
  }
}
```

**类组件**

```jsx
class ChildCom extends Component {
  constructor(props) {
    super(props)
  }
  render() {
    // 子组件解构数据并使用
    let {name, age, level} = this.props
    return (
      <div>
        <h2>姓名:{name} - 年龄: {age} - 等级: {level}</h2>
        <hr/>
      </div>
    )
  }
}
```

**函数组件**

```jsx

function ChildComF(props) {
    //函数组件不存在this,作为参数直接使用
    return (
      <div>
        <h2>姓名:{props.name} - 年龄: {props.age} - 等级: {props.level}</h2>
        <hr/>
     </div>
    )
}
```

**类型验证  props-type**

- 如果项目中默认继承 **Flow 或 TypeScript**，可直接进行类型验证
- 或者通过安装 `prop-types`库进行验证  `yarn add prop-types`

```js
//类组件
import PropTypes from "prop-types"

class ChildCom extends Component {
  // 使用静态属性
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number,
    level: PropTypes.number
  }
  static defaultProps = {
    name: '暂无',
    age: 0,
    level: 0
  }
  constructor(props) {
    super(props)
  }
  render() {
    let { name, age, level } = this.props
    return (
      <div>
        <h2>姓名:{name} - 年龄: {age} - 等级: {level}</h2>
        <hr />
      </div>
    )
  }
}
```

```jsx
//函数组件
//导入prop-types
import PropTypes from "prop-types"

function ChildComF(props) {
    return (
      <div>
        <h2>姓名:{props.name} - 年龄: {props.age} - 等级: {props.level}</h2>
        <hr/>
     </div>
    )
}

// 类型验证等 propTypes
ChildComF.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number,
  level: PropTypes.number
}
//指定 props 的默认值 defaultProps
ChildComF.defaultProps = {
  name: '暂无',
  age: 0,
  level: 0
}
```



### 子传父

- vue中通过自定义事件完成
- react中仍然通过**props**传递——**子组件保存父组件传递的回调函数引用，子组件调用该函数**



```jsx
import React, { Component } from 'react'

//子组件
class CountBtn extends Component {
    render() {
        // 子组件发生某些事件时，调用回调函数
        const {increment} = this.props
        return (
            <button onClick={increment}>+1</button>
        )
    }
}

//父组件
export default class App extends Component {
    constructor(props) {
        super(props)
        this.state = {
            counter: 0
        }
    }
    render() {
        return (
            <div>
                <h2>当前计数: {this.state.counter}</h2>
                <button onClick={e => this.increment()}>+</button>
                {/*通过props传递回调函数, 注意this的绑定*/}
                <CountBtn increment={e => this.increment()}></CountBtn>
            </div>
        )
    }
    increment() {
        console.log('increment函数被执行');
        this.setState({
            counter: this.state.counter + 1
        })
    }
}
```





## react实现slot效果

- 利用 `this.props.children`

```jsx
//父组件
render() {
    return (
      <div>
        <Test4>
          <strong>left</strong>
          <a herf="/#">百度一下</a>
          <span>right</span>
        </Test4>
      </div>
    )
}
//子组件
render() {
    return (
        <div className="navbar">
            <div className="nav-left">{this.props.children[0]}</div>
            <div className="nav-center">{this.props.children[1]}</div>
            <div className="nav-right">{this.props.children[2]}</div>
        </div>
    )
}
```

- 利用 `props` 与 JSX

```jsx
//父组件
render() {
    return (
      <div>
        <Test5 
            leftSlot={<strong>left</strong>} 
            centerSlot={<a herf="/#">百度一下</a>} 
            rightSlot={<span>right</span>}/>
      </div>
    )
}
//子组件
render() {
    const {leftSlot, centerSlot, rightSlot} = this.props
    return (
        <div className="navbar">
            <div className="nav-left">{leftSlot}</div>
            <div className="nav-center">{centerSlot}</div>
            <div className="nav-right">{rightSlot}</div>
        </div>
    )
}
```



## 跨组件通信 - 多级props

- **属性展开**——可以使用展开运算符在JSX中传递整个props对象 **{...this.props}**

```jsx
export default class Test6 extends Component {
    render() {
        return (
            <ToolBar theme="dark" color="red"></ToolBar>
        )
    }
}
class ToolBar extends Component {
    render() {
        return (
            <ThemeButton {...this.props}></ThemeButton>
        )
    }
}
function ThemeButton(props) {
    return (
        <button 
            style={{backgroundColor: props.theme, color: props.color}}
        >主题按钮</button>
    )
}
```



## 跨组件通信 - Context

- 用于共享在组件树中的全局数据，如：用户数据、主题、语言等

- **React.createContext**

  - 创建一个Context对象，当 React 渲染一个订阅了这个 Context 对象的组件，该组件会从组件树中离自身最近的那个匹配的 `Provider` 中读取到当前的 context 值
  - **只有**当组件所处的树中没有匹配到 Provider 时，其 `defaultValue` 参数才会生效

  ```js
  const MyContext = React.createContext(defaultValue)
  ```

  

- **Content.Provider**

  - 每个 Context 对象都会返回一个 **Provider React 组件，允许消费组件订阅 context 的变化**
  - Provider 接收一个 `value` 属性，传递给消费组件
  - 当 Provider 的 `value` 值发生变化时，它内部的所有消费组件都会重新渲染
  - Provider 及其内部 consumer 组件都不受制于 `shouldComponentUpdate` 函数

  ```html
  <MyContext.Provider value={/*某个值*/}>
  ```



- **Class.contextType**

  - 挂载在 class 上的 `contextType` 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象
  - 使用 `this.context` 来消费最近 Context 上的那个值

  ```jsx
  class MyClass extends React.Component {
    componentDidMount() {
      let value = this.context;
      /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */
    }
    render() {
      let value = this.context;
      /* 基于 MyContext 组件的值进行渲染 */
    }
  }
  MyClass.contextType = MyContext;
  ```

  

- **Context.Consumer**

  - 让函数式组件完成订阅 context

  ```jsx
  <MyContext.Consumer>
  	{value => /*基于context值进行渲染*/}
  </MyContext.Consumer>
  ```

- **Context.displayName**

  - React DevTools 使用该字符串来确定 context 要显示的内容

  ```js
  const MyContext = React.createContext(/* some value */);
  MyContext.displayName = 'MyDisplayName';
  ```



**实例：单个Context**

```jsx
// 1.创建Content,提供默认值
const ThemeContext = React.createContext({
    color: 'pink',
    fontSize: 24
})

export default class Test7 extends Component {
    constructor(props) {
        super(props)
        this.state = {
            themeObj : { 
                color: 'blue',
                fontSize: 20
            }
        }
    }
    render() {
        return (
            // 2.提供当前Content对象的值
            <ThemeContext.Provider value={this.state.themeObj}>
                <ToolBar></ToolBar>
            </ThemeContext.Provider>
        )
    }
}
class ToolBar extends Component {
    render() {
        console.log(this.context);
        return (
            <ThemeButton></ThemeButton>
        )
    }
}

class ThemeButton extends Component {
    // 3.消费当前Content,值保存在this.context
    static contextType = ThemeContext
    render() {
        console.log(this.context);
        return (
            <button style={{
                    fontSize: this.context.fontSize + 'px', 
                    color: this.context.color}}
            >主题按钮</button>
        )
    }
}
```

```jsx
// 函数式
function ThemeButton() {
    return (
        <ThemeContext.Consumer>
            {
                value => {
                    return (
                        <button style={{fontSize: value.fontSize + 'px', color: value.color}}>主题按钮</button>
                    )
                }
            }
        </ThemeContext.Consumer>
    )
}
```





## setState的使用
